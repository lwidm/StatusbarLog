// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2025 Lukas Widmer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// -- statusbarlog/include/statusbarlog/statusbarlog.h.in

#ifndef STATUSBARLOG_STATUSBARLOG_H_
#define STATUSBARLOG_STATUSBARLOG_H_

// clang-format off

#ifdef _WIN32
#include <windows.h>
#else
#include <sys/ioctl.h>
#include <unistd.h>
#endif

#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <string>
#include <vector>

// clang-format on

namespace statusbar_log {

constexpr unsigned int kMaxHandles = 100;
constexpr unsigned int kMaxLogLength = 4096;
constexpr unsigned int kMaxFilenameLength = 256;
constexpr unsigned int kMaxPrefixLength = 80;
constexpr unsigned int kMaxPostfixLength = 80;
constexpr unsigned int kMaxBarWidth = 200;
constexpr int kStatusbarLogSuccess = 0;

/// Define to disable automatic flushing (improves performance but may delay
/// output)
constexpr bool kStatusbarLogNoAutoFlush = false;

/**
 * \enum LogLevel
 * \brief Defines log levels for categorizing message importance.
 *
 * Messages below the minimum log level (statusbar_log::kLogLevel) are ignored.
 *
 * Levels:
 * - \c kLogLevelOff: No logging
 * - \c kLogLevelErr: Logs errors to the console with the prefix "ERROR" (using
 *the `print_err` <- \todo function)
 * - \c kLogLevelWrn: Logs warnings to the console with the prefix "WARNING".
 * - \c kLogLevelInf: Logs informational messages to the console with the
 *prefix "INFO".
 * - \c kLogLevelDbg: Logs debug messages to the console with the prefix
 *"DEBUG".
 *
 * \see statusbar_log::Log: Actual function used for creating log messages.
 * \see statusbar_log::kLogLevel: Macro to set the global logging threshold.
 * \see PrintErr: Function for printing error messages -> \todo
 */
// clang-format off
typedef enum {
  kLogLevelOff = 0, ///< No logging
  kLogLevelErr, ///< Logs errors to the console with the prefix "ERROR" (using the `print_err` <- \todo function)
  kLogLevelWrn, ///< Logs warnings to the console with the prefix "WARNING".
  kLogLevelInf, ///< Logs informational messages to the console with the prefix "INFO".
  kLogLevelDbg, ///< Logs debug messages to the console with the prefix "DEBUG".
} LogLevel;
// clang-format on

/**
 * \brief Compile-time default logging threshold for the library.
 *
 * This value is generated at configure time by CMake's `configure_file()`
 *
 * Default: `kLogLevelDbg` (unless the consumer overrides via CMake).
 *
 * How to override the default (preferred):
 *  - At CMake configure time (out-of-tree):
 *      cmake -S . -B build -DSTATUSBARLOG_LOG_LEVEL=kLogLevelInf
 *
 *  - When used via add_subdirectory(), set the cache variable *before*
 *    calling add_subdirectory():
 *      set(STATUSBARLOG_LOG_LEVEL kLogLevelWrn CACHE STRING "statusbarlog
 * default") add_subdirectory(path/to/statusbarlog)
 *
 * Allowed configure-time values (must match the LogLevel identifiers):
 *   kLogLevelOff, kLogLevelErr, kLogLevelWrn, kLogLevelInf, kLogLevelDbg
 */
// clang-format off
constexpr LogLevel kLogLevel = @STATUSBARLOG_LOG_LEVEL@;
// clang-format on

/**
 * \struct StatusbarHandle
 * \brief Handle to a statusbar. Used to interact with the underlying statusbar
 * struct without directly touching it
 *
 * \see Statusbar: Underlying statusbar struct
 */
typedef struct {
  std::size_t idx;  ///< Positional index corresponding to the statusbars
                    ///< position in the registry
  unsigned int id;  ///< ID of the statusbar. Must be unique. Used to verify
                    ///< validity of statusbar
  bool valid;  ///< weather or not this statusbar is valid (for e.g. false after
               ///< destruction)
} StatusbarHandle;

/**
 * \brief Saves the current cursor position in the terminal
 */
void SaveCursorPosition();

/**
 * \brief Restores the previously saved cursor position in the terminal
 */
void RestoreCursorPosition();

/**
 * \brief Clears from the current cursor position to the end of the line
 */
void ClearToEndOfLine();

/**
 * \brief Clears from the current cursor position to the end of the line
 */
void ClearFromStartOfLine();

/**
 * \brief Clear entire current line
 */
void ClearLine();

/**
 * \brief More robust version with cursor positioning
 */
void ClearCurrentLine();

/**
 * \brief Manually flush the output buffer
 *
 * Useful when statusbar_log::kStatusbarLogNoAutoFlush is defined to force
 * output
 */
void FlushOutput();

/**
 * \brief Logs a message if its level â‰¤ statusbar_log::kLogLevel
 *
 * \param[in] log_level Severity level of this message.
 * \param[in] filename Source filename or tag (will be printed in log message,
 * should be the origin of the log message).
 * \param[in] fmt printf-style format string.
 * \param[in] ... Additional format arguments.
 *
 * \return statusbar_log::kStatusbarLogSuccess (i.e. 0) on success, non-zero on
 * formatting error. (Currently always statusbar_log::kStatusbarLogSuccess, no
 * error checking)
 *
 * \note Logging temporarily moves status bars down to avoid visual glitches.
 *
 * \see statusbar_log::LogLevel: Enum containing all log levels.
 * \see statusbar_log::kLogLevel: Macro to set the global logging threshold.
 * \see PrintErr: Function for printing error messages -> \todo
 */
int Log(LogLevel log_level, const std::string& filename, const char* fmt, ...);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wgnu-zero-variadic-macro-arguments"

/**
 * \brief Shortcut for logging warnings.
 *
 *\see statusbar_log::Log: General logging function
 */
inline int LogErr(const std::string& filename, const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  return Log(kLogLevelErr, filename, fmt);
}

/**
 * \brief Shortcut for logging warnings.
 *
 *\see statusbar_log::Log: General logging function
 */
inline int LogWrn(const std::string& filename, const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  return Log(kLogLevelWrn, filename, fmt);
}

/**
 * \brief Shortcut for logging informational messages.
 *
 *\see statusbar_log::Log: General logging function
 */
inline int LogInf(const std::string& filename, const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  return Log(kLogLevelInf, filename, fmt);
}

/**
 * \brief Shortcut for logging debug messages.
 *
 *\see statusbar_log::Log: General logging function
 */
inline int LogDbg(const std::string& filename, const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  return Log(kLogLevelDbg, filename, fmt);
}

/**
 * \brief Initializes a Statusbar, updates its handle and prints its initial
 * state.
 *
 * This function takes an empty statusbar_handle struct and populate its
 * corresponding statusbar with the other input parameters. Additionally it sets
 * all percentages to 0 and sets the spinner-indices to 0.
 *
 * Example of a statusbar:
 *  "prefix1 string"[########/       ] 50% "postfix1 string"
 *  "prefix2 string"[#/        ] 10% "postfix2 string"
 *
 * \param[out] statusbar_handle Struct to initialize.
 * \param[in] _positions Vertical positions (1=topmost) of each bar. For e.g. if
 * you want two bars stacked on top of each other you would pass {2, 1} (2: top
 * bar, 1: lower bar).
 * \param[in] _bar_sizes Widths of each bar (characters excluding prefix,
 * postfix, percentage, '[' and '[').
 * \param[in] _prefixes Text before each bar.
 * \param[in] _postfixes Text before each bar.
 *
 * \return Returns statusbar_log::kStatusbarLogSuccess (i.e. 0) on success, or
 * one of these error/warning codes:
 *         -  statusbar_log::kStatusbarLogSuccess (i.e. 0): Success (no errors)
 *         - -1: Failed to create status bar handle (invalid inputs)
 *         - -2: Failed to create status bar handle (handle registry exceeds
 * maximum element limit)
 *
 * \warning Don't forget to destroy the statusbar_handle after use.
 *
 * \see Statusbar: The statusbar struct.
 * \see _statusbar_registry: The registry for statusbar struct in use.
 * \see _statusbar_free_handles: The registry for free statusbar handles.
 * \see UpdateStatusbar: Updating a statusbar
 * \see DestroyStatusbarHandle: Destroying statusbar_handle after use.
 */
int CreateStatusbarHandle(StatusbarHandle& statusbar_handle,
                          const std::vector<unsigned int> _positions,
                          const std::vector<unsigned int> _bar_sizes,
                          const std::vector<std::string> _prefixes,
                          const std::vector<std::string> _postfixes);

/**
 * \brief Destorys a Statusbar
 *
 * This function takes a StatusbarHandle, clears its content, adds it
 * to the _statusbar_free_handles registry and frees its position in the
 * _statusbar_registry.
 *
 *
 * \param[in, out] statusbar_handle Struct to destroy.
 *
 * \return Returns statusbar_log::kStatusbarLogSuccess (i.e. 0) on success, or
 * one of these error/warning codes:
 *         -  statusbar_log::kStatusbarLogSuccess (i.e. 0): Success (no errors)
 *         - -1: Invalid handle passed (valid flag set to false)
 *         - -2: Invalid handle passed (index out of registry bounds)
 *         - -3: Invalid handle passed (IDs don't match)
 *         - -4: Invalid handle passed (Other error)
 *
 * \see Statusbar: The statusbar struct.
 * \see _statusbar_registry: The registry for statusbar struct in use.
 * \see _statusbar_free_handles: The registry for free statusbar handles.
 * \see UpdateStatusbar: Updating a statusbar
 * \see CreateStatusbarHandle: Creating new statusbar handles.
 */
int DestroyStatusbarHandle(StatusbarHandle& statusbar_handle);

/**
 * \brief Function used for updating a statusbar given its handle. The statusbar
 * can consist of multiple "bars" of different sizes and different post-, and
 * prefixes.
 *
 * This Function takes a StatusbarHandle struct and 'updates' it by printing
 * the bar given a new percentage. The statusbar can consist of multiple bars
 * which is why an index has to be passed. This function moves the cursor to the
 * correct location in the terminal corresponding to the index, clears the row
 * and prints an updated bar.
 *
 * Example of a statusbar:
 *  "prefix1 string"[########/       ] 50% "postfix1 string"
 *  "prefix2 string"[#/        ] 10% "postfix2 string"
 *
 *
 * \param[in, out] statusbar_handle Statusbar to update.
 * \param[in] idx Index of the bar component (0-based).
 * \param[in] percent New progress percentage (0-100).
 * updated.
 *
 * \return Returns statusbar_log::kStatusbarLogSuccess (i.e. 0) on success, or
 * one of these error/warning codes:
 *         -  statusbar_log::kStatusbarLogSuccess (i.e. 0): Success (no errors)
 *         - -1: Invalid handle passed (valid flag set to false)
 *         - -2: Invalid handle passed (index out of registry bounds)
 *         - -3: Invalid handle passed (IDs don't match)
 *         - -4: Invalid handle passed (Other error)
 *         - -5: Invalid percentage passed
 *         - -6: Invalid bar index passed
 *
 * \details The spinner character cycles through { |, /, -, \ } on each update.
 *
 * \see CreateStatusbarHandle: Creating/Initializing a statusbar handle.
 * \see Statusbar: The statusbar struct.
 * \see _statusbar_registry: Global statusbar registry.
 */
int UpdateStatusbar(StatusbarHandle& statusbar, const std::size_t idx,
                    const double percent);

}  // namespace statusbar_log

#endif  // !STATUSBARLOG_STATUSBARLOG_H_
